/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( showStatus ) {

	THREE.Loader.call( this, showStatus );
	
};

THREE.JSONLoader.prototype = new THREE.Loader();
THREE.JSONLoader.prototype.constructor = THREE.JSONLoader;
THREE.JSONLoader.prototype.supr = THREE.Loader.prototype;


THREE.JSONLoader.prototype = {

	// Load models generated by slim OBJ converter with ASCII option (converter_obj_three_slim.py -t ascii)
	//  - parameters
	//		- model (required)
	//		- callback (required)
	//		- texture_path (optional: if not specified, textures will be assumed to be in the same folder as JS model file)

	load: function ( parameters ) {

		var url = parameters.model,
			callback = parameters.callback, 
		    texture_path = parameters.texture_path ? parameters.texture_path : THREE.Loader.prototype.extractUrlbase( url ),
		
			s = (new Date).getTime(),
			worker = new Worker( url );
		
		worker.onmessage = function( event ) {
			
			THREE.JSONLoader.prototype.createModel( event.data, callback, texture_path );

		};

		worker.postMessage( s );

	},
	
	createModel: function ( json, callback, texture_path ) {

		var Model = function ( texture_path ) {

			var scope = this;

			THREE.Geometry.call( this );

			THREE.Loader.prototype.init_materials( scope, json.materials, texture_path );

			parse();
			init_skin();

			this.computeCentroids();
			this.computeFaceNormals();
			
			function parse() {

				if ( json.version === undefined || json.version != 2 ) {

					console.error( 'Deprecated file format.' );
					return;

				}
	
				function isBitSet( value, position ) {
					
					return value & ( 1 << position );

				};
				
				var i, j, 
				
				type, offset,

				isTriangle, 
				hasMaterial, 
				hasFaceUv, hasFaceVertexUv,
				hasFaceNormal, hasFaceVertexNormal,
				hasFaceColor, hasFaceVertexColor,

				vertex, face,
				
				faces = json.faces,
				vertices = json.vertices,
				normals = json.normals,

				nUvLayers = json.uvs.length;

				for ( i = 0; i < nUvLayers; i++ ) {

					scope.faceUvs[ i ] = [];
					scope.faceVertexUvs[ i ] = [];

				}

				offset = 0;

				while ( vertices[ offset ] ) {

					vertex = new THREE.Vertex();
					
					vertex.position.x = vertices[ offset ++ ];
					vertex.position.y = vertices[ offset ++ ];
					vertex.position.z = vertices[ offset ++ ];

					scope.vertices.push( vertex );

				}

				offset = 0;

				while ( faces[ offset ] ) {

					type = faces[ offset ];

					isTriangle          = isBitSet( type, 0 );
					hasMaterial         = isBitSet( type, 1 );
					hasFaceUv           = isBitSet( type, 2 );
					hasFaceVertexUv     = isBitSet( type, 3 );
					hasFaceNormal       = isBitSet( type, 4 );
					hasFaceVertexNormal = isBitSet( type, 5 );
					hasFaceColor	    = isBitSet( type, 6 );
					hasFaceVertexColor  = isBitSet( type, 7 );


					if ( isTriangle ) {

						face = new THREE.Face3();
					
						face.a = faces[ offset ++ ];
						face.b = faces[ offset ++ ];
						face.c = faces[ offset ++ ];

						nVertices = 3;

					} else {

						face = new THREE.Face4();
						
						face.a = faces[ offset ++ ];
						face.b = faces[ offset ++ ];
						face.c = faces[ offset ++ ];
						face.d = faces[ offset ++ ];

						nVertices = 4;

					}

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						face.materials = [ scope.materials[ materialIndex ] ];

					}

					if ( hasFaceUv ) {

						for ( i = 0; i < nUvLayers; i++ ) {

							uvLayer = json.uvs[ i ];

							uvIndex = faces[ offset ++ ];

							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];

							scope.faceUvs[ i ].push( new THREE.UV( u, v ) );

						}

					}

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i++ ) {
							
							uvLayer = json.uvs[ i ];

							uvs = [];

							for ( j = 0; j < nVertices; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uvs[ j ] = new THREE.UV( u, v );

							}

							scope.faceVertexUvs[ i ].push( uvs );

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						normal = new THREE.Vector3();
						
						normal.x = normals[ normalIndex ++ ];
						normal.y = normals[ normalIndex ++ ];
						normal.z = normals[ normalIndex ];

						face.normal = normal;

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < nVertices; i++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new THREE.Vector3();
							
							normal.x = normals[ normalIndex ++ ];
							normal.y = normals[ normalIndex ++ ];
							normal.z = normals[ normalIndex ];

							face.vertexNormals.push( normal );

						}

					}

				
					if ( hasFaceColor ) {

						color = new THREE.Color( faces[ offset ++ ] );
						face.color = color;

					}

					
					if ( hasFaceVertexColor ) {

						for ( i = 0; i < nVertices; i++ ) {

							color = new THREE.Color( faces[ offset ++ ] );
							face.vertexColors.push( color );

						}

					}

					scope.faces.push( face );

				}

			};
			
			function init_skin() {
				
				var i, l, x, y, z, w, a, b, c, d;

				if ( json.skinWeights ) {
					
					for( i = 0, l = json.skinWeights.length; i < l; i += 2 ) {

						x = json.skinWeights[ i     ];
						y = json.skinWeights[ i + 1 ];
						z = 0;
						w = 0;
						
						scope.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

					}
					
				}
				
				if ( json.skinIndices ) {
					
					for( i = 0, l = json.skinIndices.length; i < l; i += 2 ) {

						a = json.skinIndices[ i     ];
						b = json.skinIndices[ i + 1 ];
						c = 0;
						d = 0;

						scope.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

					}
				
				}
				
				scope.bones = json.bones;
				scope.animation = json.animation;
				
			};
			
			Model.prototype = new THREE.Geometry();
			Model.prototype.constructor = Model;

			callback( new Model( texture_path ) );

		}

	}

};